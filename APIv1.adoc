= Byteport API v1.2
Byteport API documentation.
v1.2, 2016-02-15
:experimental:
:toc:
:toc-placement: preamble
:toc-title: pass:[<b>Table of Contents</b>]
:outfilesuffix-old: {outfilesuffix}
ifdef::env-github[:outfilesuffix: .adoc]
ifndef::env-github[]
:idprefix:
:idseparator: -
endif::[]

== Notes on API version
The Byteport HTTP APIv2 is under development with many additional functions.
The v1 API described in this document will be supported at least until *2016-12-31*.

Changes to the API minor number will not break the API but is a hint to added functionality only
and will *not change* the URL prefix, ie v1.0 and v1.1 clients both uses the /api/v1/ prefix.

== Changelog
=== v1.2
Added method to POST messages to devices through API method via the message broker network.
A GET to the same URL will load message history.

=== v1.1
Added mode to load namespace and device data using the new *depth* parameter. By adding depth
a device can also append its child devices in the same request.

=== v1.0
First version, all essentials for loading Namespace, Device, Device Types and Time series data.

== Introduction
If you are not instructed otherwise, all calls should be made against the following
host:

https://api.byteport.se

While it may work to access www.byteport.se for the same purpose, it may not be
so in the future.

Whenever a GET-call is made, the client receives a cookie named csrftoken. This
token must be supplied in all calls made below as csrftoken. In addition, the
same token must be supplied as the form data parameter csrfmiddlewaretoken in
any POST calls made. The csrftoken is a Cross Site Request Forgery token and
is a security measure.

The client must then login correctly to obtain the sessionid cookie before any
other service calls can be made. A HTTP POST call is made in this step.

To be able to login and use the data accessing APIs you must have met the
following prerequisites:

. Have a valid username and password to the Byteport instance you are accessing
. The user must have access to the namespace you are working against.
. Knowledge and understanding of the concepts namespace, device uid and
field name etc. For a brief primer on this subject, read below.


== Names
At the heart of Byteport are the time series data that are continuously stored from
your devices. All data are stored vs a unique key called a Byteport GUID. The key
is defined like this:

`*[Namespace name].[Device UID].[Field name]*`

Example, logging the speed of a mining cart uses this valid name

*megamine.cart-44.Speed1*

The names used in the Byteport GUID must all adhere to the following rules:

- Must be between 2 characters and 32 characters long.
- Can not contain other characters than: 0-9, a-z,A-Z, dash, underscore and colon.
- Can not start with dash (-) or underscore (_).

In addition, a namespace created by a user must be longer than 6 characters.


=== Reserved fields
Any field name starting with an underscore character (_) will not be stored as a data field.
Such fields are reserved meta fields to the Byteport data receiver. There are only two field
name in use for this purpose at the moment, but further functionality may be added:

|===
|Field name | Description

|_key
|The API key to the namespace.

|_ts
|A custom timestamp for all the data supplied in the call.
|===


The following fields are not meta fields, but pose a special function as they are interpreted as log messages and will
be displayed in various panels for the purpose, operations summary reports etc.
|===
|Field name |Description

|debug
|Log messages of DEBUG level. Stored on device level only.

|info
|Log messages of INFO level. Stored on device level only.

|warn
|Log messages of WARN level. Stored on device namespace level.

|error
|Log messages of ERROR level. Stored on device namespace level.
|===


== Storing data using API-key method

This method does not require the client to login to obtain the sessionid but
instead you need to enable the namespace to accept writes by API-keys.
See the namespace security-tab in the Byteport instance
(go here: https://www.byteport.se/manager/namespaces/, select namespace and
open up “Security”).

It is highly recommended to include a timestamp in each call as there is no
guarantee the data is immediately parsed and stored.

=== Store multiple data points for a device

[cols="h,5a"]
|===

| URL
| /api/v1/timeseries/[namespace]/[device uid]/

| Method
| POST, GET

| Parameter(s)
|
_key::
 The namespace API key
_ts::
 UNIX Timestamp in seconds since epoch.
[any other]::
 Interpreted as data fields

| Response Body
| N/A

|===

=== Examples

==== Example 1
Storing a heartbeat using curl, no data is supplied, that is supported:

 $ curl --data "_key=1D3c2" "http://api.byteport.se/api/v1/timeseries/mySpace/10/"

==== Example 2:
When supplying data, you may also supply a timestamp in seconds since UNIX epoch. All other parameters will be
interpreted as application data, values can be any common number format or a string:

 $ curl --data "_key=1D3c2&_ts=1410613385.123&temp=20&last_word=mom" "http://api.byteport.se/api/v1/timeseries/mySpace/10/"


== Log in
To access stored data from a client, the client will first need to log in to obtain the sessionid cookie. The flow
to complete a successful login vs. Byteport is as follows

. Obtain *csrftoken*
. Perform the actual login, include csrftoken as Cookie and set *username*, *password*, and *csrfmiddlewaretoken*
as POST parameters.
. Store the returned *sessionid* cookie for future API requests.

=== Obtain CSRFTOKEN
The first thing to to is to make a simple GET call vs the login URL to obtain the csrftoken cookie.

[cols="h,5a"]
|===

| URL
| /api/v1/login/

| Method
| GET

| Response Set-Cookie
| csrftoken

|===

=== Perform the actual login
Now supply the csrftoken as a cookie, as well as a request parameter in the POST call together with the username and password:

[cols="h,5a"]
|===

| URL
| /api/v1/login/

| Method
| POST

| Cookie
| csrftoken (*must* be supplied regardless of also being set as POST data)

| Parameter(s)
|
username::
password::
csrfmiddlewaretoken::
 The CrossSiteRequestForgery token obtained as a Set-cooke in the GET request earlier.

| Response Set-Cookie
| csrftoken, sessionid

| Response Body
| N/A

|===

The server will respond with a Set-Cooke called *sessionid* that must be
included in any subsequent call where the logged in context is needed.


== Log out
Log out by doing any kind of request to the log out URL. Server will respond with 200 OK upon successful logout. This
will invalidate your current sessionid, and you will need to obtain a new one by logging in again.

[cols="h,5a"]
|===

| URL
| /api/v1/logout/

| Method
| Any

| Response code
| 200


|===


== Echo
This method will echo back the supplied GET parameters as JSON data and does not require a logged in session.

[cols="h,5a"]
|===

| URL
| /api/v1/echo/

| Method
| GET

| Response code
| 200

| Content type
| application/json

| Response Body
|
....
{
    test: "hello world"
}

|===

== Data access methods

=== Namespace

[cols="h,5a"]
|===

| URL
| /api/v1/namespace/

| Method
| GET

| Cookie
| csrftoken, sessionid

| Parameter(s)
|
key::
 Show information for a single namespace by adding this parameter, key is the name of the namespace.

| Content type
| application/json

| Response Body
|
....
[
    {
        data_survival_time: "0",
        name: "test",
        read_by_key: "True",
        http_write_method: "both",
        read_key: "",
        write_by_key: "True",
        write_key: "FOOBARKEY",
        description: "A very pleasant space"
    }
]
....
|===

=== Free text search for devices
Search for device in all namespace the logged in user has access to

[cols="h,5a"]
|===

| URL
| /api/v1/search_devices/

| Method
| GET

| Cookie
| csrftoken, sessionid

| Parameter(s)
|
term::
 a string matching any device *guid*. A device guid is the namespace.uid combination. Append a . to perform
 an exact search vs guid (ie. the Namepspace.Device UID combo).
full::
 *true* or *false*, to return the full object, or just the GUID
limit::
 maximum result size. default is a low number such as 10 or 20

| Content type
| application/json

| Response Body
|
....
{
    meta: {
        term: "test"
    },
    data: [
        "test.100",
        "test.101",
        "test.102",
        "test.103",
        "test.104",
        "test.105",
        "test.106",
        "test.107",
        "test.108",
        "test.109"
    ]
}
....
|===

=== Device
Query for devices in a namespace.

[cols="h,5a"]
|===

| URL
| /api/v1/namespace/[namespace]/device/

| Method
| GET

| Cookie
| csrftoken, sessionid

| Parameter(s)
| key::
 a string matching any device *guid*. A device guid is the namespace.uid combination. Append a * to perform
 a wild card search.
 uid::
  Same as key
 depth::
  Default is 0 and will show the list of UIDs. Increasing to 1, 2 or 3 will show a more detailed object with more related
  objects, such as data, device type and child devices etc.

| Content type
| application/json

| Response Body
|
....
[
    {
        timeout_limit: "180",
        active: "True",
        commands_changed: "False",
        uid: "100",
        namespace: "test",
        offline_alarm: "False",
        crypto_key: "",
        alarm_repeat_times: "0",
        device_type: "Mätare (test)",
        reduction_coefficient: "10",
        guid: "test.100",
        description: "basdf",
        extra_field_2: "",
        extra_field_1: "",
        last_contact: null,
        lon: "18.0721836091",
        undefined_fields: [ ],
        photo: "",
        last_contact_pretty: "never",
        clock_skewed: null,
        public: "False",
        status: "offline",
        service_level: "100",
        current_firmware: "None",
        sticky_command: "False",
        reg_code: "2EE49C30D091A2FA",
        parent_device: "test.TestGW",
        location_hint: "",
        is_online: false,
        lat: "59.3264882345",
        last_alarm: "None",
        alarm_interval: "5",
        alarm_acked_by: "None",
        commands: "",
        ctime: "2015-01-28 13:42:23.816541+00:00",
        alarm_repeats: "0",
        fields:
        [],
        alarm_acked_time: "None",
        last_addr: "",
        latest_data_as_dict: { },
        alias: "",
        last_provided_timestamp: null,
        alarm_emails: ""
    }
]
....
|===

=== Send message to Device
Messages can *instantly* be sent to devices connected to byteport given the devies communicates via the byteport
message broker network.

[cols="h,5a"]
|===

| URL
| /api/v1/message/[namespace]/[device uid]/$

| Method
| GET, POST (Upon successful POST, the sent message will be returned, wrapped in a JSON
  response that describes what happened, like this:
....
[
    {
        status: "Message sent to test.TestGW via channel all.",
        error_level: "0",
        user: "admin",
        send_time: "2016-02-16 14:13:36.416998+00:00",
        device: "test.100",
        message: "[{"data": "bb", "namespace": "test", "uid": "100", "timestamp": "1455632016"}]",
        id: "57"
    }
]
....

| Cookie
| csrftoken, sessionid

| Parameter(s)
|
from (GET only)::
 Message index. Default is 0 which is the last message sent.
to (GET only)::
 Message index. Default is 0, hence one message will be returned by default.
message (POST only)::
 Any ASCII text.
format (POST only)::
 Valid formats: *json* (other formats may be added)
 Wrap the message in the JSON structure like the example below. json is default.
....
 [
   { "data": "[ASCII Payload, could be another JSON structure, XML or just a string]",
     "namespace": "test",
     "uid": "100",
     "timestamp": "1455632016"
   }
 ]
....

| Content type
| application/json

|===

=== Device type
Query for the device types available in this namespace.

[cols="h,5a"]
|===

| URL
| /api/v1/namespace/[namespace]/device_type/

| Method
| GET

| Cookie
| csrftoken, sessionid

| Parameter(s)
| key::
 Filter on a specific device type *id*.

 depth::
  Default is 1, decrease to 0 to show IDs only in result, or increase to 2 to show the field definitions for this device
  type.

| Content type
| application/json

| Response Body (full=False)
|
....
[
    {
        timeout_limit: "180",
        description: "",
        accepts_children: "True",
        command_channel: "all",
        photo: "",
        namespace: "test",
        command_support: "True",
        internet_connection: "ethernet",
        id: "1",
        name: "Generic Test Gateway"
    },
    {
        timeout_limit: "180",
        description: "",
        accepts_children: "False",
        command_channel: "all",
        photo: "",
        namespace: "test",
        command_support: "False",
        internet_connection: "none",
        id: "2",
        name: "Temperature sensor"
    }
]
....
|===


=== Device type, firmware
Query for available firmware for the given device type

[cols="h,5a"]
|===

| URL
| /api/v1/namespace/[namespace]/device_type/[device type id]/firmware/

| Method
| GET

| Cookie
| csrftoken, sessionid

| Parameter(s)
| N/A

| Content type
| application/json

| Response Body
|
....
[
    {
        uploaded: "2016-01-12 13:21:20.273027+00:00",
        comment: "xbf",
        uploader: "Frank",
        md5_digest: "664bdd584bb5b65544a7d44560f2c413",
        image: "infra/firmware/test/1/1.1/d836f2d0ad7f4bd6/theFirmware1.bz2",
        enabled: "True",
        version: "1.1",
        filesize: "6",
        device_type: "Generic Test Gateway (test)",
        id: "2"
    },
    {
        uploaded: "2016-01-12 13:19:54.479065+00:00",
        comment: "sdf",
        uploader: "Ernest",
        md5_digest: "2fd2df26bc7d6741c141a302ef2318f6",
        image: "infra/firmware/test/1/1.0/95a5bc51d05583b7/fw2.zip",
        enabled: "True",
        version: "1.0",
        filesize: "8748",
        device_type: "Generic Test Gateway (test)",
        id: "1"
    }
]
....
|===

=== Device type, field definitions
Query for the field definitions for the given device type.

[cols="h,5a"]
|===

| URL
| /api/v1/namespace/[namespace]/device_type/[device type id]/field_definition/

| Method
| GET

| Cookie
| csrftoken, sessionid

| Parameter(s)
| N/A

| Content type
| application/json

| Response Body
|
....
[
    {
        description: "",
        data_type: "object",
        list_separator: "",
        object_type: "application/json",
        automation: "None",
        default_processor: "None",
        role: "def",
        device_type: "Temperature sensor",
        unit_symbol: "",
        encoding_type: "base64",
        id: "5",
        unit: "",
        name: "b64_jsons"
    },
    {
        description: "",
        data_type: "object",
        list_separator: "",
        object_type: "image/png",
        automation: "None",
        default_processor: "None",
        role: "def",
        device_type: "Temperature sensor",
        unit_symbol: "",
        encoding_type: "base64",
        id: "2",
        unit: "",
        name: "b64_pngs"
    }
]
....
|===

=== Get timeseries data

[cols="h,5a"]
|===

| URL
| /api/v1/timeseries/[namespace]/[uid]/[field name]/

| Method
| GET

| Cookie
| csrftoken, sessionid

| Parameter(s)
|
from::
 An ISO8601 datetime, %Y-%m-%dT%H:%M:%S. Example 2015-04-01T13:14:15
to::
 An ISO8601 datetime.
timedelta_minutes::
 Mintes back in time (will default ‘from’ to now in time).
timedelta_hours::
 Hours back in time (will default ‘from’ to now in time).
timedelta_days::
 Days back in time (will default ‘from’ to now in time).

| Content type
| application/json

| Response Body
|
....
{
  "meta": {
    "path": "system.ferdinand.est_ports"
  },
  "data": {
    "ts_data": [
      {
        "r": "3a6d07a6-6dec-11e5-a77b-448a5b2c3e32",
        "m": {
          "trv": "False",
          "vlen": "3",
          "hdts": "1444329706460151"
        },
        "t": "2015-10-08T18:41:46.460000",
        "v": 118
      },
      {
        "r": "5e405f16-6dec-11e5-986c-448a5b2c29cd",
        "m": {
          "trv": "False",
          "vlen": "3",
          "hdts": "1444329766565455"
        },
        "t": "2015-10-08T18:42:46.565000",
        "v": 118
      },
      {
        "r": "82151486-6dec-11e5-8d0c-448a5b2c3e32",
        "m": {
          "trv": "False",
          "vlen": "3",
          "hdts": "1444329826679719"
        },
        "t": "2015-10-08T18:43:46.679000",
        "v": 118
      }
    ],
    "ts_meta": {
      "orig_len": 3,
      "from": "2015-10-08T18:41:21.285079",
      "data_type": "number",
      "seconds": 180,
      "len": 3,
      "to": "2015-10-08T18:44:21.285079",
      "conversion_errors": 0,
      "path": "system.ferdinand.est_ports",
      "reduced": false
    }
  }
}
....
|===

=== Get single data point
Using the *r* as obtained using the above timeseries range call, the details for a single data point can be loaded.

[cols="h,5a"]
|===

| URL
| /api/v1/value/[namespace]/[uid]/[field name]/[value_ref]/

| Method
| GET

| Cookie
| csrftoken, sessionid

| Parameter(s)
| N/A

| Content type
| application/json

| Response Body
|
....
{
    uid: "unit5",
    field_name: "wifi_ss",
    value: "04:c5:a4:81:b2:03",
    meta: {
        trv: "False",
        vlen: "114",
        hdts: "1444330122274233"
    },
    timestamp: "2015-10-08T18:48:42.274233",
    ref: "3245393a-6ded-11e5-9e43-448a5b2c3e32",
    namespace_name: "test"
}
....
|===

=== Get single data point as file
Using the *r* as obtained using the above timeseries range call, the details for a single data point can be downloaded
as a file. This is typically performed on data packets. If the packet was compressed and encoded it will be uncompressed
and unencoded before sent to the client by default. The same *r* is used as in the above load of single value.

[cols="h,5a"]
|===

| URL
| /api/v1/download/value/[namespace]/[uid]/[field name]/[value_ref]/

| Method
| GET

| Cookie
| csrftoken, sessionid

| Parameter(s)
|
decode::
 true / false
decompress::
 true / false

| Content type
| application/text

| Content-Disposition
| attachment; filename=[namespace].[uid].[field name].[ISO8601 timestamp].bin

| Encoding type (if applicable)
| gzip, bzip2

|===

= Byteport asynchronous storage API v0.7
Byteport also supports an asynchronous high performance method of storing data. This is facilitated through an enterprise level
message broker and the protocols we support is:

* MQTT (port 1883)
* MQTT / SSL (port 8883)
* STOMP (port 61613)
* STOMP / SSL (port 61614)

The message broker is as of v0.7 (2016, Feb.) not open for public access. To access the broker you need a valid login
and the hostname of the broker to use. To obtain one you can contact *support@byteport.se*.

== Storing data

=== Comma separated data
The messages posted should to the broker should be valid JSON and look like the example below. Note that even if
a single message is sent, it should still be wrapped in a JSON list item and this is highly suitable for bulk
loading data into Byteport.

....
[
  {
    "namespace": "theNamespace",
    "uid": "deviceUID",
    "timestamp": "1337666777.123",
    "data": "temp=10;last_word=mom;"
  },
  {
    "namespace": "theNamespace",
    "uid": "deviceUID",
    "timestamp": "1337666787.123",
    "data": "temp=10;last_word=\"i love you\";"
  }
]
....

The data-field could contain an arbitrary amount of data values.

== Receiving data
The same broker can also be used to obtain messages from the Byteport IoT platform, typically for controlling devices
in real-time or altering device parameters etc.

All Byteport devices can listen on its designated queue, such as:

....
/queue/device_messages_NAMESPACE.DEVICEUID
....

The data sent to devices can *take on any form* as long as it is a valid ASCII string.